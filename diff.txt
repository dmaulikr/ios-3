diff --git a/Leo/LEOGradientView.m b/Leo/LEOGradientView.m
index 28b3c2b..d5d021e 100644
--- a/Leo/LEOGradientView.m
+++ b/Leo/LEOGradientView.m
@@ -103,7 +103,7 @@
 }
 
 - (void)setCurrentTransitionPercentage:(CGFloat)currentTransitionPercentage {
-    
+
     _currentTransitionPercentage = currentTransitionPercentage;
     if (currentTransitionPercentage < 0) {
         _currentTransitionPercentage = 0;
diff --git a/Leo/Views and Controllers/Appointment Flow/LEOAppointmentView.m b/Leo/Views and Controllers/Appointment Flow/LEOAppointmentView.m
index 68460e7..648ba91 100644
--- a/Leo/Views and Controllers/Appointment Flow/LEOAppointmentView.m	
+++ b/Leo/Views and Controllers/Appointment Flow/LEOAppointmentView.m	
@@ -369,6 +369,9 @@ IB_DESIGNABLE
         return NO;
     }
 
+    [self invalidateIntrinsicContentSize];
+    [self setNeedsLayout];
+
     return YES;
 }
 
@@ -399,6 +402,27 @@ IB_DESIGNABLE
 
 #pragma mark - Autolayout
 
+- (void)layoutSubviews {
+    [super layoutSubviews];
+    NSLog(@"BODY layout subviews %@", NSStringFromCGRect(self.frame) );
+}
+
+- (void)updateConstraints {
+    [super updateConstraints];
+    NSLog(@"BODY update constraints %@", NSStringFromCGRect(self.frame) );
+}
+
+-(CGSize)intrinsicContentSize {
+
+    CGFloat intrinsicHeight = self.visitTypePromptView.textView.bounds.size.height +self.patientPromptView.textView.bounds.size.height + self.notesTextView.bounds.size.height + self.staffPromptView.textView.bounds.size.height + self.schedulePromptView.textView.bounds.size.height;
+
+//    intrinsicHeight += 400;
+
+    return CGSizeMake(300, intrinsicHeight);
+}
+
+
+
 - (void)setupTouchEventForDismissingKeyboard {
 
     UITapGestureRecognizer *tapGestureForTextFieldDismissal = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(viewTapped)];
diff --git a/Leo/Views and Controllers/Appointment Flow/LEOAppointmentViewController.m b/Leo/Views and Controllers/Appointment Flow/LEOAppointmentViewController.m
index 1cec398..97d504d 100644
--- a/Leo/Views and Controllers/Appointment Flow/LEOAppointmentViewController.m	
+++ b/Leo/Views and Controllers/Appointment Flow/LEOAppointmentViewController.m	
@@ -148,6 +148,8 @@ static NSString *const kKeySelectionVCDate = @"date";
         CGPoint start;
         CGPoint end;
 
+        [self.stickyHeaderView layoutIfNeeded];
+
         CGRect rect = self.gradientView.bounds;
         CGFloat r = CGRectGetHeight(rect) / CGRectGetHeight(self.gradientView.gradientLayerBounds);
 
@@ -156,6 +158,12 @@ static NSString *const kKeySelectionVCDate = @"date";
         CGFloat theta = atanf(CGRectGetWidth(rect)/(CGRectGetHeight(rect)/2));
         [LEOGradientHelper gradientStartPoint:&start endPoint:&end withCenter:center withRadius:r withRotationInRadians:theta];
 
+        start.x *= 2;
+        start.y *= 2;
+        end.x *= 2;
+        end.y *= 2;
+
+
         self.gradientView.initialStartPoint = start;
         self.gradientView.initialEndPoint = end;
 
@@ -166,6 +174,7 @@ static NSString *const kKeySelectionVCDate = @"date";
         theta = atanf(CGRectGetWidth(rect)/(CGRectGetHeight(rect)/2));
         [LEOGradientHelper gradientStartPoint:&start endPoint:&end withCenter:center withRadius:r withRotationInRadians:theta];
 
+
         self.gradientView.finalStartPoint = start;
         self.gradientView.finalEndPoint = end;
         
@@ -185,7 +194,7 @@ static NSString *const kKeySelectionVCDate = @"date";
 
         LEOGradientView *strongView = [LEOGradientView new];
         _gradientView = strongView;
-        _gradientView.colors = @[(id)[UIColor leo_green].CGColor, (id)[UIColor leo_white].CGColor];
+        _gradientView.colors = @[(id)[UIColor leo_green].CGColor, (id)[UIColor leo_redBadge].CGColor];
         _gradientView.titleText = self.card.title;
     }
 
diff --git a/Leo/Views and Controllers/Generic/LEOStickyHeaderView.m b/Leo/Views and Controllers/Generic/LEOStickyHeaderView.m
index e7d7634..e494edb 100644
--- a/Leo/Views and Controllers/Generic/LEOStickyHeaderView.m	
+++ b/Leo/Views and Controllers/Generic/LEOStickyHeaderView.m	
@@ -16,6 +16,7 @@ CGFloat const kTitleViewTopConstraintOriginalConstant = 0;
 @interface LEOStickyHeaderView ()
 
 @property (nonatomic) BOOL breakerIsOnScreen;
+@property (nonatomic) BOOL snapTransitionInProcess;
 @property (strong, nonatomic) CAShapeLayer *pathLayer;
 @property (weak, nonatomic) UIView *titleView;
 @property (strong, nonatomic) NSLayoutConstraint* titleViewTopConstraint;
@@ -51,6 +52,13 @@ CGFloat const kTitleViewTopConstraintOriginalConstant = 0;
     return self;
 }
 
+- (void)dealloc {
+
+    // ????: is there ever a time where scrollView gets deallocated before this method is called?
+    [self.scrollView removeObserver:self forKeyPath:@"contentSize"];
+    [self.scrollView removeObserver:self forKeyPath:@"contentOffset"];
+}
+
 - (void)commonInit {
 
     // default values
@@ -74,7 +82,6 @@ CGFloat const kTitleViewTopConstraintOriginalConstant = 0;
         UIView *strongFooterView = [UIView new];
         _footerView = strongFooterView;
 
-
         [self.scrollView addSubview:_contentView];
         [_contentView addSubview:_bodyView];
         [_contentView addSubview:_titleView];
@@ -84,7 +91,7 @@ CGFloat const kTitleViewTopConstraintOriginalConstant = 0;
     return _contentView;
 }
 
-- (UIScrollView *)scrollView {
+- (TPKeyboardAvoidingScrollView *)scrollView {
 
     if (!_scrollView) {
 
@@ -93,6 +100,8 @@ CGFloat const kTitleViewTopConstraintOriginalConstant = 0;
 
         [self addSubview:_scrollView];
 
+        [_scrollView addObserver:self forKeyPath:@"contentSize" options:NSKeyValueObservingOptionNew context:nil];
+
         _scrollView.delegate = self;
 
         _scrollView.showsHorizontalScrollIndicator = NO;
@@ -122,6 +131,8 @@ CGFloat const kTitleViewTopConstraintOriginalConstant = 0;
     UIView *strongBodyView = [self.datasource injectBodyView];
     _bodyView = strongBodyView;
 
+    [_bodyView addObserver:self forKeyPath:@"frame" options:NSKeyValueObservingOptionNew context:nil];
+
     [self.contentView addSubview:_bodyView];
 }
 
@@ -179,6 +190,28 @@ CGFloat const kTitleViewTopConstraintOriginalConstant = 0;
         self.snapToHeight = @(headerHeight);
     }
 
+    [self updateScrollInsetsToAllowForCollapse];
+
+    [super layoutSubviews];
+}
+
+-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context {
+
+    if ([keyPath isEqualToString:@"contentSize"] && object == self.scrollView) {
+
+        // header should always be either expanded or collapsed, never in between
+//        BOOL shouldChangeFromCollapsedToExpanded = [self isCollapsed] && [self titleViewShouldSnapToExpandedState];
+//        BOOL shouldChangeFromExpandedToCollapsed = ![self isCollapsed] && [self titleViewShouldSnapToCollapsedState];
+//        BOOL shouldAnimateSnap = ([self scrollViewAtBottomPosition] && shouldChangeFromCollapsedToExpanded) || (![self scrollViewAtBottomPosition] && shouldChangeFromExpandedToCollapsed);
+
+//        [self navigationTitleViewSnapsForScrollView:self.scrollView animated:NO];
+
+        [self updateScrollInsetsToAllowForCollapse];
+    }
+}
+
+- (void)updateScrollInsetsToAllowForCollapse {
+
     // determine content size via autolayout
     [self.scrollView layoutIfNeeded];
 
@@ -186,16 +219,19 @@ CGFloat const kTitleViewTopConstraintOriginalConstant = 0;
     CGFloat differenceBetweenExpandedAndCollapsedHeights = CGRectGetHeight(self.titleView.bounds) - [self navBarHeight];
     if (0 < maxPossibleOffsetY && maxPossibleOffsetY < differenceBetweenExpandedAndCollapsedHeights) {
 
+        //if bigger than the frame but not large enough to collapse
         CGFloat insetHeight = differenceBetweenExpandedAndCollapsedHeights - maxPossibleOffsetY;
         self.scrollView.contentInset = UIEdgeInsetsMake(0, 0, insetHeight, 0);
+    } else {
+
+        self.scrollView.contentInset = UIEdgeInsetsZero;
     }
 
     self.scrollView.bounces = ![self scrollViewContentSizeSmallerThanScrollViewFrameIncludingInsets];
-
-    [super layoutSubviews];
 }
 
 
+
 -(BOOL)scrollViewContentSizeSmallerThanScrollViewFrameIncludingInsets {
     return self.scrollView.contentSize.height < (self.scrollView.bounds.size.height - self.scrollView.contentInset.bottom - self.scrollView.contentInset.top);
 }
@@ -333,21 +369,40 @@ CGFloat const kTitleViewTopConstraintOriginalConstant = 0;
 
     [self animateBreakerIfNeeded];
 
-    // header should scroll with the body until it reaches collapsed position
+    // holds position of title view once it reaches the collapsed state
     BOOL shouldStayInCollapsedPosition = offset.y > [self heightOfTitleView] - [self navBarHeight];
     BOOL shouldStayAtTopDuringBounce = self.headerShouldNotBounceOnScroll && offset.y < 0;
 
     if (shouldStayInCollapsedPosition) {
 
+        // moves title view down while scrolling to keep in the same position
         self.titleViewTopConstraint.constant = offset.y - [self heightOfTitleView] + [self navBarHeight];
     } else if (shouldStayAtTopDuringBounce) {
 
+        // difference between bounce below title view and bounce above title view
         self.titleViewTopConstraint.constant = offset.y;
     } else {
 
+        // ensures that title view stays "attached" to body view during scroll
         self.titleViewTopConstraint.constant = kTitleViewTopConstraintOriginalConstant;
     }
 
+
+
+
+
+    if (!self.snapTransitionInProcess && [self scrollViewAtBottomPosition]) {
+
+        // if weve reached the bottom
+
+        NSLog(@"at bottom!");
+
+
+    } else {
+
+
+
+
     // inform the delegate about the transition status
     CGFloat percentage = [self transitionPercentageForScrollOffset:offset];
     percentage = percentage > 1 ? 1 : percentage;
@@ -355,6 +410,8 @@ CGFloat const kTitleViewTopConstraintOriginalConstant = 0;
     if ([self.delegate respondsToSelector:@selector(updateTitleViewForScrollTransitionPercentage:)]) {
         [self.delegate updateTitleViewForScrollTransitionPercentage:percentage];
     }
+
+    }
 }
 
 -(CGFloat)transitionPercentageForScrollOffset:(CGPoint)offset {
@@ -376,7 +433,7 @@ CGFloat const kTitleViewTopConstraintOriginalConstant = 0;
         BOOL bouncing = scrollView.contentOffset.y < 0;
         if (!bouncing) {
 
-            [self navigationTitleViewSnapsForScrollView:scrollView];
+            [self navigationTitleViewSnapsForScrollView:scrollView animated:YES];
         }
     }
 }
@@ -385,36 +442,72 @@ CGFloat const kTitleViewTopConstraintOriginalConstant = 0;
 
     if (scrollView == self.scrollView) {
 
-        decelerate ? nil : [self navigationTitleViewSnapsForScrollView:scrollView];
+        decelerate ? nil : [self navigationTitleViewSnapsForScrollView:scrollView animated:YES];
     }
 }
 
--(void)navigationTitleViewSnapsForScrollView:(UIScrollView *)scrollView {
+- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView {
+
+    if (scrollView == self.scrollView) {
+
+        [self navigationTitleViewSnapsForScrollView:scrollView animated:YES];
+    }
+}
+
+- (BOOL)titleViewShouldSnapToExpandedState {
+    return [self scrollViewVerticalContentOffset] < [self heightOfNoReturn];
+}
+
+- (BOOL)titleViewShouldSnapToCollapsedState {
+    return [self scrollViewVerticalContentOffset] > [self heightOfNoReturn] && [self scrollViewVerticalContentOffset] < [self heightOfHeaderCellExcludingOverlapWithNavBar];
+}
+
+- (BOOL)scrollViewAtBottomPosition {
+
+    CGFloat maxPossibleOffsetY = self.scrollView.contentSize.height - CGRectGetHeight(self.scrollView.bounds) + self.scrollView.contentInset.bottom;
+    return self.scrollView.contentOffset.y == maxPossibleOffsetY;
+}
+
+
+
+-(void)navigationTitleViewSnapsForScrollView:(UIScrollView *)scrollView animated:(BOOL)animated {
 
     if (self.isCollapsible) {
 
-        // Force collapse
-        if ([self scrollViewVerticalContentOffset] > [self heightOfNoReturn] && [self scrollViewVerticalContentOffset] < [self heightOfHeaderCellExcludingOverlapWithNavBar]) {
+        void (^animations)() = ^{};
 
-            [UIView animateWithDuration:0.1 delay:0.0 options:UIViewAnimationOptionCurveEaseOut animations:^{
+        void (^completion)(BOOL) = ^(BOOL finished) {
 
-                scrollView.contentOffset = CGPointMake(0.0, [ self heightOfHeaderCellExcludingOverlapWithNavBar]);
-            } completion:^(BOOL finished) {
+            self.snapTransitionInProcess = NO;
+            [self animateBreakerIfNeeded];
+        };
 
-                [self animateBreakerIfNeeded];
-            }];
+        // Force collapse
+        if ([self titleViewShouldSnapToCollapsedState]) {
+
+            self.snapTransitionInProcess = YES;
+            animations = ^{
+
+                scrollView.contentOffset = CGPointMake(0.0, [self heightOfHeaderCellExcludingOverlapWithNavBar]);
+            };
         }
 
         // Force expand
-        else if ([self scrollViewVerticalContentOffset] < [self heightOfNoReturn]) {
-
-            [UIView animateWithDuration:0.1 delay:0.0 options:UIViewAnimationOptionCurveEaseOut animations:^{
+        else if ([self titleViewShouldSnapToExpandedState]) {
 
+            self.snapTransitionInProcess = YES;
+            animations = ^{
                 scrollView.contentOffset = CGPointMake(0.0, 0.0);
-            } completion:^(BOOL finished) {
+            };
+        }
+
+        if (animated) {
+
+            [UIView animateWithDuration:0.5 animations:animations completion:completion];
+        } else {
 
-                [self animateBreakerIfNeeded];
-            }];
+            animations();
+            completion(YES);
         }
     }
 }
@@ -434,7 +527,7 @@ CGFloat const kTitleViewTopConstraintOriginalConstant = 0;
 }
 
 - (CGFloat)heightOfNoReturn {
-    return [self heightOfTitleView] * kHeightOfNoReturnConstant;
+    return 0; // [self heightOfTitleView] * kHeightOfNoReturnConstant;
 }
 
 - (CGFloat)heightOfHeaderCellExcludingOverlapWithNavBar {
diff --git a/Pods/TPKeyboardAvoiding/TPKeyboardAvoiding/UIScrollView+TPKeyboardAvoidingAdditions.m b/Pods/TPKeyboardAvoiding/TPKeyboardAvoiding/UIScrollView+TPKeyboardAvoidingAdditions.m
index 84b6b03..e86a607 100644
--- a/Pods/TPKeyboardAvoiding/TPKeyboardAvoiding/UIScrollView+TPKeyboardAvoidingAdditions.m
+++ b/Pods/TPKeyboardAvoiding/TPKeyboardAvoiding/UIScrollView+TPKeyboardAvoidingAdditions.m
@@ -192,7 +192,7 @@ static const int kStateKey;
     // behavior which automatically ensures that the first responder is within its bounds
     dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
         [self setContentOffset:idealOffset animated:YES];
-        
+
         state.ignoringNotifications = NO;
     });
 }
